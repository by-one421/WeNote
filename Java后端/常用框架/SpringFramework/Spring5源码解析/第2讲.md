# BeanFactory的实现
其实beanFactory的实现类我们之前看到一个，他就是DefaultListableBeanFactory。
```java
DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
```
一开始创建里面没有任何的bean的。需要去添加一些bean的定义，而不是去添加一些bean对象。因为对象是beanFactory去创建的（控制反转）。
bean的定义就是描述你的beand的特征，比如类型（class）, 单例还是多例（scope）, 有没有初始化方法，销毁方法，是否懒加载等等。
下面通过编程方式去添加一个Bean的定义：
```java
@Configuration
static class Config {
    @Bean
    public Bean1 bean1() {
        return new Bean1();
    }

    @Bean
    public Bean2 bean2() {
        return new Bean2();
    }
}

```
```java

DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
// 构建一个beanDefinition
AbstractBeanDefinition beanDefinition =
                BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope("singleton").getBeanDefinition();
//注册beanDefinition
beanFactory.registerBeanDefinition("config", beanDefinition);
//打印查看是否添加成功
for (String name : beanFactory.getBeanDefinitionNames()) {
	System.out.println(name);
}


//输出：
config
```
运行上面结果只输出：config
那有同学可能会疑问，@Configuration配置类加了@Bean 为啥没注册进去 ? 
也就是@Configuration和@Bean并没有起到作用，说明beanFactory的功能不完整，需要添加一些常用的后处理器
```java
DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
AbstractBeanDefinition beanDefinition =
                BeanDefinitionBuilder.genericBeanDefinition(Config.class).setScope("singleton").getBeanDefinition();
beanFactory.registerBeanDefinition("config", beanDefinition);

 // 给 BeanFactory 添加一些常用的后处理器，对beanFactory进行扩展。
AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);

for (String name : beanFactory.getBeanDefinitionNames()) {
	System.out.println(name);
}

```
运行上面代码输出：
```java
输出：
config
//处理Configuration注解，以及里面的@Bean注解
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
```
以上代码只是添加了一些后置处理器，可以看到bean1和bean2还是没有的。我们需要执行这些后置处理器
```java
beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().forEach(beanFactoryPostProcessor -> {
     beanFactoryPostProcessor.postProcessBeanFactory(beanFactory);
});
for (String name : beanFactory.getBeanDefinitionNames()) {
	System.out.println(name);
}
```
运行上面代码输出：可以看到bean1和bean2已经添加成功了。
```java
config
org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
bean1
bean2
```
beanFactoryPostProcessor后面会讲，关键是要了解到Spring的beanFactory原始功并不丰富。他的扩展功能是由一些后置处理器来帮我们完成的。

